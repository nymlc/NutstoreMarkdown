`HTTP`协议很明显是不安全的，信息可能被劫持篡改，目标端也可能身份伪装等等安全问题

# HTTP的缺点

`HTTP`有以下不足：

+ 通信使用明文，内容可能被窃听
+ 不能验证通信方身份，可能遭遇伪装
+ 无法证明报文完整性也就是可能被篡改

这不仅仅是`HTTP`的问题，其它未加密的协议也有这些问题

## 通信使用明文可能会被窃听

`HTTP`不具备加密功能，也就是无法对请求或者响应的内容进行加密

### TCP/IP 是可能被窃听的网络

所谓互联网就是能连接到全世界的网络组成，我们和某台服务器通信，这个通信线路上的设备、光缆、计算机等等不可能都是私人的也就是可能被窥视

即使加密过的也会被窥视，只是看到的是加密过的内容，不惧窥视而已

窃听通信也不难，只需要收集到流动的数据包如何解析就行了，可借助抓包工具来完成，就像`Wireshark`

### 加密处理防止被窃听

加密是一种最常见的防止被窃听的手段，加密的对象通常有以下几个：

+ 通信的加密

  `HTTP`协议本身没有加密的手段，但是可以通过`SSL(Secure Socket Layer)`或者`TLS(Transport Layer Security)`建立安全线路来加密通信内容，与`SSL`的组合使用就是`HTTPS`了

+ 内容的加密

  这个就是自己把通信的内容给加密，这样子就要求双端都要加解密的能力，而且因为不像`SSL`加密了整个通信线路，所以内容还是要被篡改的可能

## 不验证通信方的身份就可能遭遇伪装

`HTTP`协议是不会确认通信方的，也就是你不知道你访问的服务端是不是就是你想的那个，服务端也不知道对方是不是自己想要回应的那个

+ 任何人都可发起请求

  也就是服务端只要接收到请求都会响应，虽然简单了，不过会导致以下几个隐患：

  + 不能确定访问的目标服务器就是你想要的那个
  + 不能确定接收响应的客户端就是你想的那个
  + 不能确定通信的对方是否有相应权限，毕竟有些数据可能很重要
  + 不能确定请求来源
  + 不能处理无意义的请求，这就导致`DoS(Denial of Service)`攻击

+ 查明对手的证书

  `SSL`可以使用一种叫做证书的手段来确认通信方。这个证书呢就是通过值得信任的第三方机构颁发的，也就是这个服务端和客户端是人为确认真实存在的，也就是只要确认通信方持有的证书就可以确认通信的真实意图

## 无法证明报文完整性，可能已遭篡改

得判断信息的完整性

+ 接收到的内容可能有误

  就像你去某网站下载文件是不能确定你下载到的文件就是那个服务器上的那个，因为可能被人在中途篡改了，这个就是中间人攻击

+ 如何防止篡改

  比较常见的就是根据服务端提供的`MD5`来校验。不过这个得用户去手动验证，浏览器不能自动校验，而且这个也不保险，毕竟`MD5`也可能被篡改

# HTTP + 加密 + 认证 + 完整性保护 =HTTPS

## HTTP加上加密处理和认证以及完整性保护后即是HTTPS

我们把添加了加密、认证机制的`HTTP`称为`HTTPS`

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdown20200607001522.png" alt="image-20200606212502269" style="zoom:50%;" />

## HTTPS是身披SSL外壳的HTTP

`HTTPS`不是应用层的新协议，只是`HTTP`通信接口部分采用`SSL`和`TLS`协议代替而已

本来呢`HTTP`和`TCP`通信，当使用`SSL`时就会先和`SSL`通信然后`SSL`和`TCP`通信

`SSL`是独立的协议，其它运行在应用层的`SMTP、Telnet`等协议都可以配合`SSL`协议使用

## 相互交换密钥的公开密钥加密技术

我们先了解下加密方法，`SSL`采用的是公开密钥加密

### 共享密钥加密的困境

加密和解密共用一个密钥就是共享密钥加密，也叫对称密钥加密

这个有很大的问题，因为共用密钥就得把密钥发给对方这个就有问题，毕竟可以安全的转发密钥的话还要加密干嘛，而且保管密钥也是问题

### 使用两把密钥的公开密钥加密

公开密钥加密使用俩把密钥，一把公开一把私有

发送密文的一方使用对方公开的密钥加密，对方接收到密文就可以使用私钥解密了

### HTTPS 采用混合加密机制

我们不能都使用共享密钥加密，因为不安全，也不能都使用公开密钥加密，毕竟加密效率低

我们可以使用公开密钥加密去传送共享密钥加密的密钥，这样子我们就可以使用共享密钥加密进行通信

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdown20200607001601.png" alt="image-20200607001600300" style="zoom:50%;" />

> 共享密钥加密（DES、AES）：
>
> + 优点：算法公开、加密效率快计算量小
> + 缺点：密钥要是泄露不安全、每对用户的密钥都不一样，也就是密钥对数量巨大，使得密钥管理成为负担
>
> 公开密钥加密（RSA）：
>
> + 优点：安全
> + 缺点：加密计算量大效率低
>
> 

## 证明公开密钥正确性的证书

看起来混合加密机制很完美其实还是有漏洞，因为公开密钥加密需要传送公开密钥，这个可能被篡改

这时候就是**证书**登场了，我们使用数字证书认证机构（`CA`）颁发的公开密钥证书

流程就是服务器运营人员先去证书机构申请公开密钥，通过之后就会对申请密钥做数字签名，并且将其与公钥证书绑定，服务端就会把公钥证书发给客户端，公钥证书也叫数字证书或者就叫证书

证书包含了公钥、加密算法、`HASH`算法等等。但是这个证书发给客户端它怎么知道这个证书是对的呢？我们可以把这些信息做个`HASH`，然后用私钥给这个结果加密得到数字签名附在证书末尾。这样子客户端可以使用**认证机关的的公钥**解密这个数字签名得到`HASH`，然后自己也计算个`HASH`，俩个一比较就知道是否被篡改了

那个这里的关键就是公开密钥的安全转发了，所以很多浏览器会直接内置常用的认证机关的公开密钥

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdown20200607011619.png" alt="image-20200607011617665" style="zoom:50%;" />

### 可证明组织真实性的 EV SSL 证书

我们知道证书可以用于确认通信一方的服务器是否规范，它还有另外一个作用就是确认服务器背后的企业是否真实存在，有这个特性的证书就是`EV SSL（Extended Validation SSL
Certificate）`证书

就是颁发的严格来确保的，有此证书的网站的地址栏背景色是绿色

### 用以确认客户端的客户端证书

和服务端证书一样是用于确认客户端是否是预料之内的客户端

这个因为证书是付费的，且和用户数挂钩，这个就不大现实，所以一般是安全性极高的网站才会这么干

比如登录中国银行网银就需要安装证书，但是其实也不保险，毕竟它只能确认客户端实际存在，也就是有了这台电脑的控制权，谁操作都一样

### 认证机构信誉第一

证书的安全性建立在颁发机构的可靠性上，要是他们被攻破从而颁发了伪造证书那么自然就没有安全性可言，就像`2011/7`的`DigiNotar`认证机构被入侵

一旦发生这种事可以从客户端删除根证书颁发机构或者将证书无效化，不过不是立即生效

### 由自认证机构颁发的证书称为自签名证书

就是自己给自己颁发证书，也就只能达到向外宣传**我是XXX**，很明显这个是不能匹配上浏览器内置的**公钥**，也就没什么安全性可言

## HTTPS 的安全通信机制

`HTTPS`的通信步骤

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdown20200607130310.png" alt="image-20200607013205628" style="zoom:50%;" />

+ 客户端发出请求
  1. 客户端发送`Client Hello`报文告诉服务端我要开始`SSL`通信，报文包含客户端支持的`SSL`版本、加密组件列表（加密算法、密钥长度等等）

+ 服务端发出响应
  2. 服务端若是可进行`SSL`通信（支持的`SSL`版本和客户端提供的匹配得上）就会以`Server Hello`报文作为回应，报文包括`SSL`版本、加密组件（从客户端提供的加密组件筛选出来的）
  3. 发送`Certificate`报文，报文包含公开密钥证书
  4. 发送`Server Hello Done`告诉客户端最初的`SSL`握手结束

+ 客户端发出请求
  5. `SSL`第一次握手结束，客户端会发送`Client Key Exchange`报文，它包含通信加密里使用的被叫做`Pre-master secret`的随机密码串，该报文用证书里的公开密钥加密
  6. 客户端继续发送`Change Cipher Spec`报文，它会告诉服务端此报文之后通信会采用`Pre-master secret`密钥加密
  7. 客户端再发送`Finished`报文，它包含包含至今为止所有的报文的校验值，本次握手是否成功就看服务端能否解密该报文
+ 服务端发出响应
  8. 服务端响应`Change Cipher Spec`报文
  9. 服务端响应`Finished`报文
+ 客户端发出请求
  10. 上面的服务端和客户端的`Finished`报文交换完毕之后`SSL`连接建立完成，这里开思就是应用层的数据通信，也就是可以发送`HTTP`请求
+ 服务端发出响应
  11. 服务端发送`HTTP`响应
+ 客户端发出请求
  12. 客户端断开连接会发送`close notify`报文，之后再发送`TCP FIN`报文来关闭与`TCP`通信

> 我们假设`A`是客户端，`B`是服务端，加密消息放在`[]`里，处理动作说明用`()`
>
> **A：**我想和你安全通信，我这里有共享密钥加密算法`DES、RC5`，公开密钥加密算法`RSA、DH`，摘要算法`MD5、SHA`**（步骤1）**
>
> **B：**那我们用`DES-RSA-MD5`好了**（步骤2）**，这是证书，里面有我的信息和公开密钥你拿去验证下我的身份**（步骤3）**，目前没什么可说的了**（步骤4）**
>
> **A：**（查看证书有效性，通过内置的`CA`公钥来解数字签名得到的结果和自己计算的`HASH`做个比较），(整一个秘密消息，它把一个叫做`Pre-master secret`的随机数用`B`的公开密钥加密（证书那获取），保证只有`B`才能看)
>
> 我发给你一个秘密消息，用你的公钥加密的**（步骤5）**，注意，此后我要用加密方式和你说话了**（步骤6）**，**[**目前没什么可说的了**]（步骤7）**
>
> **B：**（用私钥解密`Client Key Exchange`，也就是这时候拿到了客户端的提供的共享密钥，双方已经具备了加密条件）
>
> **[**注意，我也要用加密方式和你通话了**]（步骤8）**
>
> **[**目前没什么可说的了**]（步骤9）**
>
> **A：[**我的秘密是...**]（步骤10）**
>
> **B：[**其他人听不见...**]（步骤11）**

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdown20200608010316.png" alt="image-20200608010314802" style="zoom:50%;" />

这是整个流程的图解

### SSL和TLS

`TLS`是以`SSL3.0`为基准制定的协议，有时会统称为`SSL`，目前主流是`SSL3.0`和`TLS1.0`

### SSL速度慢吗

`HTTPS`存在处理速度慢的问题

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdown20200607130255.png" style="zoom:50%;" />

`SSL`慢在俩处，一是加解密消耗`CPU`资源，二是通信消耗网络资源

和`HTTP`相比多了`SSL`通信，这样子不可避免的增加通信量

针对速度慢这是没有根本性的解决方案，我们会**采用`SSL`加速器这种硬件**来改善问题，相对于软件来说可以提高数倍`SSL`计算速度

### 为什么不一直使用 HTTPS

通过以上知识肯定也大致知道为什么了

加密通信消耗内存资源，所以一般而言不是敏感的都用`HTTP`，尤其是访问量很大的网站在进行加密处理的时候可以不对所有的内容加密以此节约资源

购买证书也是一笔开销，就像个人网站一般怎么可能去买证书呢

