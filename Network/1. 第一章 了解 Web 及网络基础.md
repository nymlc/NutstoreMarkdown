# 使用HTTP协议访问Web

`Web`浏览器根据地址栏的`URL`从`Web`服务器端获取资源然后渲染出来，这种通过发送请求获取服务器资源的如`Web`浏览器等可称为**客户端**

既然是客户端向服务端请求，那么必然需要一种通用的规则，这个就是`HTTP(HyperText Transfer Protocol)`，超文本传输协议，也就是对规则的约定，`Web`就是建立在`HTTP`协议上通信的

# HTTP的诞生

了解由来可以助我们理解

## 为知识共享而规划`Web`

1989.3，一个叫蒂姆·伯纳斯-李的大神提出了能让相隔俩地的人可以共享知识的设想：**借助多个文档相互关联（通过超链接跳转）形成的超文本，连成可以相互参阅的`WWW(World Wide Web)`万维网**

当然现在不是这么简单的设想，它包含三种`WWW`构建技术：

+ `HTML`页面标记语言
+ `HTTP`文档传递协议
+ `URL`指定文档所在

> `WWW`是当年用来浏览超文本的文档系统名称，现在就是表示这一系列的集合，也可以简称为`Web`

## Web成长时代

## 驻足不前的HTTP

+ HTTP/0.9

  1990年问世，这个很简单，只有`GET`命令，那时的`HTTP`还不是正式的标准

+ HTTP/1.0

  1996.5，`HTTP`作为正式标准公布，版本被命名为`HTTP/1.0`，这个就完善了很多

+ HTTP/1.1

  1997.1，仅仅半年多时间它就被公布了，也是目前主流的版本

当年`HTTP`协议出现是为了解决文本传输问题，当然现在它早已超出了`Web`这个框架运用在各种场景里了

# 网络基础 TCP/IP

通常使用的网络是在`TCP/IP`协议族基础上运作，`HTTP`属于它的子集

## TCP/IP 协议族

计算机与网络设备（路由器啥的）通信，双方就得基于同样的方法，比如需要确定如何探测到通信目标、哪边发起通信、怎么结束通信等等规则。不同的操作系统、硬件通信这些都需要一种规则，这就是协议

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdownimage-20200520193545527.png" alt="image-20200520193545527" style="zoom: 50%;" />

协议包含各种各样内容，从电缆规格、`IP`地址选定方法、寻找异地用户方法、双方建立通信顺序等等，这样子把这么些互联网相关协议集合起来就叫`TCP/IP`，之所以叫`TCP/IP`协议族就是这俩个最常见很有代表性

## TCP/IP 的分层管理

`TCP/IP`很重要的一点就是分层，分层是有好处的，要是不分层的话一旦需要更改设计就需要整体替换，分层的话就不用了。而且层次化后设计也简单了，本层只管好本层的就行

按层次分为四层：

+ 应用层：就是定义数据格式然后按照对应的格式解读数据，协议族内预存了各种通用的应用服务，比如`FTP、DNS、HTTP`
+ 传输层：提供俩台计算机的应用通信（实现端口到端口的通信），有俩个协议：`TCP`，`UDP`
+ 网络层：处理数据包，它就是在众多的路径里选择一条传输路线传输数据包
+ 数据链路层：处理连接网络的硬件部分，比如控制操作系统、硬件设备驱动（网卡）、光纤等，硬件的范畴都在该层。主要工作就是对电信号分组形成数据帧

## TCP/IP 通信传输流

利用`TCP/IP`协议族进行网络通信会通过分层顺序进行通信，发送端是从应用层开始往下走，接收端是从数据链路层往上走

我们访问一个网站就是会在应用层发一个`HTTP`请求，然后到了传输层就会把数据分割打上序号和端口号，接着到了网络层就会加上`Mac`地址，最后到了链路层。接收端在链路层收到数据就会层层"解开"，这样子在应用层就能取到传输的数据了

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdownimage-20200520203219026.png" alt="image-20200520203219026" style="zoom: 50%;" />

如图所示，发送端每过一层就会加上那层的首部信息，接收端就会去掉那层的首部信息，这就是封装数据

# 与 HTTP 关系密切的协议 : IP、TCP 和 DNS

## 负责传输的IP协议

## 确保可靠性的 TCP 协议

`TCP`位于传输层，提供**可靠**的字节流服务，就是为了方便传输将大块数据分割成报文段为单位的数据包进行处理（[https://draveness.me/whys-the-design-tcp-segment-ip-packet/](https://draveness.me/whys-the-design-tcp-segment-ip-packet/)，就是物理设备的限制）。就是该协议为了更容易传输大数据把数据分割且能确保是否送达到对方

可靠性就是三次握手，它不会对传出去的数据置之不理而是会确认是否成功送达

1. 发送端首先发一个带有`SYN`标志的数据包过去，这就是第一次握手（发送端知道发送端有发送数据能力；接收端知道发送端有发数据能力、接收端有收数据能力）
2. 接收端收到之后就会回传`SYN/ACK`标志的数据包回去（发送端知道发送端、接收端有收发数据能力；接收端知道发送端有发数据能力、接收端有收发数据能力）**也就是接收端还不知道发送端有接收数据能力**
3. 发送端回传带有`ACK`标志数据包，代表握手结束，这样子接收端就知道发送端有接收数据能力

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdownimage-20200520210607680.png" alt="image-20200520210607680" style="zoom: 50%;" />

> SYN（synchronize，同步） 和 ACK（acknowledgement，确认）

# 负责域名解析的 DNS 服务

`DNS`服务属于应用层协议，提供域名和`IP`地址之间的解析

毕竟计算机和人不一样，它需要`IP`地址，我们则不大可能去记住`IP`地址，我们擅长记住域名地址，所以需要做个映射

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdownimage-20200520211106682.png" alt="image-20200520211106682" style="zoom: 50%;" />

# 各种协议与 HTTP 协议的关系

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdownimage-20200521203628774.png" alt="image-20200521203628774" style="zoom: 50%;" />

# URI 和 URL

## 区别

URI（Uniform Resource Identifier，统一资源标识符）、URL（Uniform Resource Locator，统一资源定位符），这俩个关系就是URL是URI子集

举个例子，身份证号码是唯一的可以把你独一无二的标识出来，这就是URI。但是身份证上的地址加上你的名字也可以定位到你，也起到了URI的作用，这是定位，根据定位来的也叫URL，我们访问某个网页也是IP、端口、页面地址都加上，这种定位的就是URL了

## URI 格式

<img src="https://cdn.jsdelivr.net/gh/nymlc/picgo@master/uPic/1616579569114.png" alt="image-20200521203815836" style="zoom: 50%;" />

其实就和一个请求的URL是一样的只是多了登录信息而已

+ 查询字符串：用于传参
+ 片段标识符：用于定位文档内的某个位置，也就是锚点

