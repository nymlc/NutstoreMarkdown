# 性能指标



# OSI、TCP/IP

## OSI

OSI（Open System Interconnect）也就是开放式网络互联，它是ISO（国际标准化组织）提出制定的一个概念模型，我们下文就是以它来展开
<img src="https://img-blog.csdn.net/20180115133703203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2MxOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="OSI" style="zoom: 67%;" />

## TCP/IP
`TCP/IP`（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）指的是能够在多个不同的网络间实现传输的协议蔟，它不仅仅只`TCP、IP`，还包含`FTP、SMTP`等等，这么叫是因为这俩货具有代表性
和`OSI`不一样的是它是先有协议和应用然后提出模型

> 它有分4层、5层的，前者是实际应用的结构，但是为了便于理解分为5层

### 4层

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdown20200615224221.png" alt="image-20200615224212087" style="zoom:50%;" />

### 5层

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdown20200615224235.png" alt="image-20200615224231570" style="zoom:50%;" />

# 层次设计目的

试想一下一台杭州的计算机发一个消息，北京的一台计算机是怎么收到的？

[https://zhuanlan.zhihu.com/p/40676462](https://zhuanlan.zhihu.com/p/40676462)

# 探索版

## 物理层

你买了台电脑，第一件事肯定得联网，联网自然就需要找根网线或者连个WiFi（无线电），这就是物理层干的事，也就是你得整个物理介质把电脑连起来

它规定了网络的一些特性，就像电气特性负责传送`0、1`电信号

## 数据链路层

### 概念

单纯的`0、1`肯定是不行的，你想一个大文件超级多的`0、1`，这让接收方怎么检查传的数据`ok`不`ok`，要是分组了，数据传输有问题只要重新传输有问题的那组数据就行了

**它就是规定电信号怎么分组**

### 以太网协议

早期各家公司有自己的划分，但是肯定会统一，所以以太网就出现了

它规定一组电信号就是一个数据包也叫**一帧**，分为目的地址、源地址、类型、帧数据、`CRC`

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdown20200616010257.png" alt="image-20200615234537867" style="zoom: 50%;" />

### Mac地址

这个我们都知道，但是不知道的是以太网规定连入网络的设备必须得有**网卡**接口，数据包得从一块网卡传送到另一块网卡，而网卡的地址也就是`Mac`地址

网卡出厂的时候`Mac`地址就是独一无二的，长度是48个二进制，我们常见的是12个十六进制数（前6个是厂商编号，后6个是厂商网卡标识，也就是同一个厂商的网卡后6位肯定不一样）

### 广播

首先我们怎么知道你想要访问的那台计算机的网卡`Mac`地址（其实这么说有问题），这就需要`ARP`协议了

我们有了`Mac`地址之后怎么发送数据包呢？

以太网用的是很暴力的做法，它把数据发给本网络内所有的计算机，每台计算机自己判定是不是给自己的（通过目的地址和自身的`Mac`地址匹配判断），这就是广播

> 就像老师在台上讲课，下面的每个学生都能收到

> 我们现在有了数据包定义、网卡`Mac`地址、广播，数据链路层就可以在计算机之间传数据了

## 网络层

### 为什么需要网络层？

我们知道数据链路层是通过广播方式去发送数据，但这个很明显有重大缺陷以及限制，杭州和北京的计算机怎么可能在同一个子网？广播这玩意子网内玩玩，不能想象整个互联网的计算机会收到其它计算机的所有的包

这就需要划分子网，整个互联网也就是由大大小小的网组起来的

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdown20200616010249.png" alt="image-20200616002426329" style="zoom:50%;" />

如图所示，我们`A`要向`B`发送信息就得先找见`B`所在的子网，当然得先判断下是不是在同一个子网（在的话就不用那么费劲了，之前说的就可以搞定），`Mac`地址没办法做到这点

这就导致了**网络层**出现，它引进了一套新的地址使得我们可以判断计算机是否属于同一个子网，这就是网址

网址和`Mac`地址是无关的，它们随机组合，网址是管理员（`ISP`）分配的

### IP协议

定义了网址的协议就是`IP`协议，所以网址也就是`IP`地址

通过`IP`地址和子网掩码我们就可以判断俩台计算机是不是属于同一个子网

> `IP`协议就是给计算机分配`IP`地址以及确定哪些地址属于同一个子网

### IP数据包

就像以太网协议的数据包，`IP`协议发的数据就是`IP`数据包

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdown20200616010242.png" alt="image-20200616003734022" style="zoom:50%;" />

很明显，`IP`数据包可以超过`1500`也就是以太网数据包的数据长度，而我们传输是把`IP`数据包放进以太网数据里，这样子要是超过了`1500`就得分割成多个以太网数据包分开发送

### ARP协议

`IP`数据包是放在以太网数据包里发送的，也就是我们需要知道`Mac`地址和`IP`地址，`IP`地址我们是已知的，所以我们得知道`Mac`地址

这个就得分为俩种情况：

+ 不在同一个子网：这个就没办法知道对方的`Mac`地址，只能把数据包发给网关
+ 在同一个子网：可以使用`ARP`协议，它发一个数据包，包含了要查询的主机`IP`，`Mac`地址就填`FF:FF:FF:FF:FF:FF`，表示是个广播地址。所在子网的所有主机都会收到，这样子就可以根据解析到的`IP`和自己的匹配下，一样的话就回复自己的`Mac`地址



## 传输层

### 为什么需要传输层？

到这里我们已经有了`Mac`地址和`IP`地址，按理来说我们已经可以在互联网上任意俩台主机建立通信了，但还不够

你计算机肯定不止一个软件，就像`QQ、微信`，这时候要是来了个数据包怎么判断它是给QQ还是给微信呢？也就是我们还需要一个**变量**来判断这个数据报到底给哪个进程使用，它就是**端口**，它是每一个使用网卡的进程编号

端口是`0 ~ 65535`之间的一个整数，正好16个二进制位。其中`0 ~ 1023`被系统占用，我们只能用其它的

> 传输层就是建立**端口到端口**的通信，网络层是**主机到主机**的通信，只要确定了主机和端口就可以实现进程间的通信
>
> `Unix`系统就把**主机+端口**称为套接字（socket）

### UDP协议

我们现在就需要在数据包里加入端口，所以我们就需要新的协议，`UDP`就是其中一个

<img src="https://raw.githubusercontent.com/nymlc/picgo/master/markdown20200616010237.png" alt="image-20200616005114680" style="zoom:50%;" />

### TCP协议

`UDP`简单但是不靠谱，它只管传消息，传的怎么样它管不着，所以`TCP`就出来了，可以近似理解为靠谱的`UDP`

## 应用层

这个就是我们用户接触的一层

### 为什么需要应用层？

我们有了前面四层已经可以拿到数据了，但是数据来源很多啊，比如`Email、FTP、WWW`等等，这就需要各种协议来规定下这么些数据格式，网页数据格式啥样、电子邮件啥样等等，这就是应用层

### DHCP协议
+ 静态`IP`地址
我们知道一台新电脑联网需要我们设置四个参数：本机`IP`、子网掩码、网关`IP`、`DNS`
<img src="https://cdn.jsdelivr.net/gh/nymlc/picgo@master/uPic/1616579473209.png" alt="image-20200619145207639" style="zoom:50%;" />
如图所示，设置即可，这四个参数一般由管理员提供（`ISP`），这就是静态`IP`地址
> 这个对于普通用户而言肯定有门槛，而且你占了这个`IP`别人就用不了了
+ 动态`IP`地址
我们可以在子网里整一台主机来对子网内的主机做动态分配这四个参数，也就是电脑开机之后会向这台主机请求这四个参数，这样子就解决了静态`IP`地址的缺点，这就是`DHCP`协议，如下图所示
<img src="https://cdn.jsdelivr.net/gh/nymlc/picgo@master/uPic/1616579483485.png" alt="image-20200619140642751" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/nymlc/picgo@master/uPic/1616579501031.png" alt="image-20200619154005571" style="zoom: 33%;" />

`DHCP`协议是应用层协议，建立在`UDP`协议之上，如图所示
1. 以太网首部应该设置本机`Mac`地址和`DHCP`主机`Mac`地址，后者不知道就填`FF:FF:FF:FF:FF:FF`
2. `IP`首部应该设置本机`IP`地址和`DHCP IP`地址，俩个都不知道，那么前者填`0.0.0.0`，后者填`255.255.255.255`
3. `UDP`就得填端口号，本机就填`68`，`DHCP`就填`67`，这是系统固定的
以太网是广播发送，所以每台机子都会收到，不过因为接收方`Mac`地址是`FF:FF:FF:FF:FF:FF`，所以不知道什么情况就得分析`IP`数据包，发现发出方`IP`是`0.0.0.0`，接收方`IP`是`255.255.255.255`，那么`DHCP`主机就应该知道这是发给自己的
然后它就会分析这个包的数据，分配好`IP`地址等，响应一个数据包，不过这个响应数据包的以太网数据包`Mac`地址已经齐了，`IP`数据包的`DHCP IP`地址也在了，`UDP`还是`68\67`，这俩个系统固定的，然后分配的参数就在`DHCP`数据包的数据内
这样子计算机收到这个响应包就知道自己的`IP、网关、子网掩码、DNS`了

### DNS协议
它是应用层协议，不过这个流程可就复杂多了

`DNS`就是用来解析网址返回对应的`IP`地址的，毕竟`IP`地址可不好记

这样子一来`DNS`服务器肯定得设置成高并发、分布式了，毕竟想想这个访问量，这就有了域名层级

**端口53**

#### 域名层级

`www.baidu.com`其实是`www.baidu.com.root`，因为所有的域名都有`.root`也就是**根域名**，所以也就省略了。根域名下一个就是**顶级域名**，也就是`.com`，再就是**次级域名**，就是`.baidu`，这个很明显可以自己注册的，最后就是**主机名也就是三级域名**，`www`

#### 解析顺序

假定访问`www.google.com`

1. 浏览器缓存：浏览器会在自己的缓存里看下有没有`www.google.com`对应的`IP`
2. 系统缓存（`hosts`）：浏览器缓存没找见就会看下`hosts`文件里有没有对应的
3. 路由器缓存：还没有的话就会在路由器缓存里找，**到此为止都是客户端的`DNS`缓存**
4. `ISP DNS缓存`：这个一般是`DHCP`给的，也就是你的运营商给的，比如电信、移动，那么就是去他们的`DNS`缓存服务器去查，我们也叫它**本地DNS服务器**
5. 根域名服务器：全世界也就13台根域名服务器，它不直接域名解析，它会判断这个域名（`.com`）是谁管的，然后返回该顶级域名服务器（`.com`）地址，本地`DNS`服务器拿到之后就会请求这台服务器
6. 顶级域名服务器：要是它没办法搞定就会返回下一级的域名服务器（`google.com`）给本地`DNS`服务器
7. 次级域名服务器：要还是搞不定那它就返回下一级域名服务器，就是一级一级下去
8. 缓存：拿到`IP`地址就会保存在本地缓存，下次就可以不用查询了

## 整体流程

上面一溜串下来数据包结构就大致如下了

<img src="https://cdn.jsdelivr.net/gh/nymlc/picgo@master/uPic/1616579523691.png" alt="image-20200619103303936" style="zoom: 33%;" />

发送这个包需要对方的俩个地址：`Mac`地址、`IP`地址

<img src="https://cdn.jsdelivr.net/gh/nymlc/picgo@master/uPic/1616579526152.png" alt="image-20200616002426329" style="zoom:50%;" />

还是这张图，这个`A`发送请求到`B`，这也就是不同子网通信，那么`A`得先发数据包给自己子网的**网关**，网关再通过路由协议转发给`B`所在的子网网关，然后再转发给`B`

### 栗子

假定我们设置好了网络参数：

```shel
IP地址：   192.168.0.100
子网掩码：  255.255.255.0
网关：     192.168.0.1
DNS：     8.8.8.8
```

我们访问`www.baidu.com`

1. 首先就是通过`DNS`查询其`IP`，向`8.8.8.8`发送一个数据包，`DNS`服务器回应`39.156.69.79`

2. 然后判断下本机和这个`IP`对应的服务器是不是在一个子网。也就是算下这俩个`IP`的网络号，本机是`192.168.0.0`，百度是`39.156.69.0`，很明显不是同个子网，所以我们得向本机所在子网网关发送数据包，由它转发
3. 应用层是`HTTP`协议；`TCP`协议整的是端口，因为是`HTTP`，所以接收方是`80`端口，发送方就随机生成；`IP`协议就是设置双方`IP`；以太网协议发送方得是网卡`Mac`地址，接收方得是所在子网网关`Mac`地址（`ARP`获得）
4. 百度收到请求会通过`TCP`将`HTTP`响应发回来，本机就会拿到给的`HTML`等资源就可以渲染网页了



# 理论版

## 物理层

**物理层是规定传输媒体接口的标准**，我们知道传输介质有双绞线、同轴电缆、光纤、红外线、无线、激光等等，它不管物理介质是啥，只要可以按它规定传输数据就行

就像电平，`+10V ~ +15V`表示`0`，`-10V ~ -15V`表示`1`，只要传输电信号的网线可以表示这个特性就行，不管啥材料



### 光纤传输

网卡传输的数据是电信号，光纤传输的是光脉冲信号，有光脉冲表示`1`，无光脉冲表示`0`，光的频率高，所以得把电信号转为光信号，到服务器的时候再转为电信号

### 物理层设备中继器

线路传输的信号功率会逐渐衰减，衰减到一定程度就会失真

中继器可以对信号进行再生和还原以增加信号的传输距离，中继器俩端连接的是不同的网段（使用同一物理层设备能够直接通讯的）而不是子网

### 信道

信道就是往一个方向传送信息，一条通信线路包含接收、发送信道，信道分为：

+ 单工通信信道：就是只能一个方向通信，就像电视、收音机
+ 半双工通信信道：双方不能同时发送或者接收，就像对讲机
+ 全双工通信信道：双方可以同时发送、接收，就像手机、电话



## 数据链路层

